#pragma config(Motor,  port1,           FRWheel,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RConveyor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           DRLauncher,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LConveyor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           DLLauncher,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           BLWheel,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ULLauncher,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BRWheel,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           URLauncher,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          FLWheel,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"

/*
int right = 5;
int left = 0;
bool leftSide = true;

void LRarc (int left,int right,int waitTime);
void Conveyor (int power, int waitTime);
*/

int driveAdj = 35;

void pre_auton()
{
	//bStopTasksBetweenModes = true;
	slaveMotor(DRLauncher, ULLauncher);
	slaveMotor(DLLauncher, ULLauncher);
	slaveMotor(URLauncher, ULLauncher);
	slaveMotor(RConveyor, LConveyor);
}

task autonomous()
{
		motor[ULLauncher] = 127;
		wait1Msec(1700);
		motor[ULLauncher] = 79;
	wait1Msec(2100); //SLOWDOWN TIME
	motor[LConveyor] = 127;
		wait1Msec(500); //***RUN TIME>>>>>>>>>>>>>>>
		motor[LConveyor] = 0;
		wait1Msec(2700); //WINDUP TIME
		motor[LConveyor] = 127;
	wait1Msec(600); //***RUN TIME>>>>>>>>>>>>>>>>>
	motor[LConveyor] = 0;
	wait1Msec(2800); //WINDUP TIME
	motor[LConveyor] = 127;
		wait1Msec(700); //***RUN TIME>>>>>>>>>>>>>>>
		motor[LConveyor] = 0;
		wait1Msec(2200); //WINDUP TIME
		motor[LConveyor] = 127; //***FINAL RUNOUT>>>
		//CURRENT WAIT TIME: 13400
}

task usercontrol()
{

	while (true)
		{
			//Prototype X-Drive
			motor[FLWheel] = vexRT[Ch3] + vexRT[Ch4] + (vexRT[Btn7U] * driveAdj) - (vexRT[Btn7D] * driveAdj) - (vexRT[Btn7L] * driveAdj) + (vexRT[Btn7R] * driveAdj);
			motor[BLWheel] = vexRT[Ch3] - vexRT[Ch1] + (vexRT[Btn7U] * driveAdj) - (vexRT[Btn7D] * driveAdj) + (vexRT[Btn8L] * driveAdj) - (vexRT[Btn8R] * driveAdj);
			motor[FRWheel] = vexRT[Ch2] - vexRT[Ch4] + (vexRT[Btn8U] * driveAdj) - (vexRT[Btn8D] * driveAdj) + (vexRT[Btn7L] * driveAdj) - (vexRT[Btn7R] * driveAdj);
			motor[BRWheel] = vexRT[Ch2] + vexRT[Ch1] + (vexRT[Btn8U] * driveAdj) - (vexRT[Btn8D] * driveAdj) - (vexRT[Btn8L] * driveAdj) + (vexRT[Btn8R] * driveAdj);


			//Conveyor

			motor[LConveyor] = 127 * ( ( vexRT[Btn6U] - vexRT[Btn6D] ) + ( vexRT[Btn6UXmtr2] - vexRT[Btn6DXmtr2] ) + vexRT[Btn8DXmtr2] );

			//Launcher
motor[ULLauncher]=((vexRT[Btn8LXmtr2]*48)+(vexRT[Btn8UXmtr2]*60)+(vexRT[Btn8RXmtr2]*80)+(vexRT[Btn8DXmtr2]*84)+((-2*(vexRT[Btn5DXmtr2]-0.5))*((vexRT[Btn7RXmtr2])+(vexRT[Btn7DXmtr2]*2)+(vexRT[Btn7LXmtr2]*4)+(vexRT[Btn7UXmtr2]*8))))+(vexRT[Ch3Xmtr2]/6);
		}
}

/*
void LRarc (int left,int right,int waitTime)
{
	motor[FLWheel] = left;
	motor[FRWheel] = right;
	motor[BRWheel] = right;
	motor[BLWheel] = left;
	wait1Msec(waitTime);
	motor[FLWheel] = 0;
	motor[BLWheel] = 0;
	motor[FRWheel] = 0;
	motor[BRWheel] = 0;
}*/
